# 8: Слой бизнес-логики

Дата: 2025-10-10

## Статус

Принят

## Проблема

Фреймворк Ruby on Rails строится на основе паттерна MVC, поэтому в нем детально прописываются требования к контроллерам (C), моделям (M) и представлениям (V). В то же время слой бизнес-логики никак не регламентируется. Поэтому сервис-объекты оформляются по произвольным правилам. Хорошо бы договориться в Ruby-командах, что допустимо использовать в service-объектах, а что нет.

Хорошее введение в проблематику можно найти у Антона Давыдова в выступлении на RubyRussia https://www.youtube.com/watch?v=DfU6H-8qal8

## Решение

Код в приложении можно разделить на архитектурные слои. Мы можем обращаться к компонентам внутри слоя и компонентам подчиненных слоев.

![](images/image1.png)

Например, мы можем из контроллеров обращаться к моделям и сервисам. Сервисы-объекты могут обращаться к моделям. Но в моделях мы не используем сервис-объекты: это признак того, что мы пытаемся реализовать бизнес-логику в моделях (она должна быть в сервисах).

**Мы используем тонкие модели**

Модели и контроллеры в MVC предназначены для разделения реализации и представления результатов. Мы не должны реализовывать бизнес-логику в классах моделей. Это означает, что там по возможности не должно быть лишних методов. Эти методы не должны что-то сериализовывать, или что-то вычислять, или связываться с другой моделью в обход ассоциаций или пытаться валидировать сразу несколько моделей. Как только мы это делаем, мы покрываем какой-то один случай (в личном кабинете, админке, фоновом задании). При этом моделью, как источником данных из базы данных будут пользоваться все. Всем остальным придется подстраиваться под уже реализованные методы. Плюс появляется соблазн насоздавать своих методов.

Не храним бизнеc-логику в модели. 

**Мы используем тонкие контроллеры**

Идеально если контроллер помещается на одном экране и состоит только из коротких экшенов. Если есть возможность обойтись без колбэков - обходимся без них. В private-области мы реализуем только permit-методы, методы для колбэков (но лучше если бы их было поменьше или не было бы вообще).

**Бизнес-логика**

Cервис-объекты описывают бизнес-логику и располагаются в папке app/contexts. Внутри этой папки располагаем подпапки с названиями бизнес-доменов, стараясь следовать кричащей архитектуре: все что относится к пользователю располагаем в app/contexts/users, все что относится к товарному чеку в app/contexts/checks и т.д. Названия папок должны отражать в первую очередь бизнес-логику, а не детали технологии или механизмы фреймворка.

**Точка входа сервис-объекта**

1. Сервис-объект представляет собой класс, логика которого реализуется в инстанс-методах.
2. У сервис-объекта может быть только одна точка входа: call. Метод perform используется только для ActiveJob-классов.
3. Голоса разделились как инициализировать сервис-объекты: большинство высказалось за вариант

```ruby
Services::Users::MaxEvents.call(params)
```

однако допускаются альтернативы:

```ruby
Users::MaxEventsServices.new.call(params)
Users::MaxEventsServices.new(options).call(params)
Users::MaxEventsServices.new(params).call
```

4. Метод для точки входа объявляется открытым — все остальные методы: закрытыми. По возможности разделяем сервис-объекты для операций и хранения состояний. Первые не дают внешний доступ к instance-полям сервисного объекта (@var), вторые возвращают Result-объекты, для возврата состояния из сервис-объекта с операциями. Для Result-объектов допускается множество точек входа.

**Модуль Callable**

Основной способ организации обращения к сервис-объектам реализован через метод класса:

```ruby
Users::MaxEventsServices.call(params)
```

Это не единственный способ, но самый распространенный. Так как он используется в каждом втором сервис-объекте, для его поддержки реализован специальный модуль Callable, который подмешивается в сервис-объект.

## Заключение

Бизнес-логику храним в папке app/contexts, используем кричащую архитектуру для папок, отражающую предметную область. Кроме того, используем модуль Callable, чтобы добиться вызова сервис-объекта в формате: `Users::MaxEventsServices.call(params)`.

